---
title: "Chapter 10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.





# Chapter 10. Case Study: Compressive Strength of Concrete Mixtures 

## 10.1 Model building strategy

## 10.2 Model performance

## 10.3 Optimizing compressive strength

## 10.4 Computing 

```{r}
library(AppliedPredictiveModeling)
data(concrete)
str(concrete)
```

```{r}
str(mixtures)
```

```{r}
library(Hmisc)
library(caret)
featurePlot(x = concrete[,-9], y = concrete$CompressiveStrength,
            # add some space between the panels 
            between = list(x=1, y=1),
            # add a background grid ('g') and a smoother ('smooth')
            type = c("g","p","smooth"))
```

```{r}
library(plyr)
averaged <- ddply(mixtures, 
                  .(Cement, BlastFurnaceSlag, FlyAsh, Water, Superplasticizer, CoarseAggregate, FineAggregate, Age),
                  function(x) c(CompressiveStrength = mean(x$CompressiveStrength)))
set.seed(100)
forTraining <- createDataPartition(averaged$CompressiveStrength, p=3/4)[[1]]
trainingSet <- averaged[forTraining,]
testSet <- averaged[-forTraining]
```

```{r}
modFormula <- paste("CompressiveStrength ~ (.)^2 + I(Cement^2) + I(BlastFurnaceSlag^2) + I(FlyAsh^2) + ",
                    "I(Water^2) + I(Superplasticizer^2) + I(CoarseAggregate^2) + I(FineAggregate^2) + I(Age^2)" )
modFormula <- as.formula(modFormula)
```

```{r}
controlObject <- trainControl(method = "repeatedcv", repeats = 5, number = 10)
```

```{r, warning=FALSE}
set.seed(669)
linearReg <- train(modFormula, data = trainingSet, method = "lm", trControl = controlObject)
linearReg
```


```{r}
set.seed(669)
plsModel <- train(modFormula, data = trainingSet, method = "pls", preProc = c("center", "scale"),
                  tuneLength = 5, trControl = controlObject)
plsModel
```

```{r}
enetGrid <- expand.grid(.lambda = c(0, 0.001, 0.01, 0.1), .fraction = seq(0.05, 1, length = 20))
set.seed(669)
enetModel <- train(modFormula, data = trainingSet, method = "enet", preProc = c("center", "scale"),
                   tuneGrid = enetGrid, trControl = controlObject)
enetModel
```

```{r}
set.seed(669)
earthModel <- train(CompressiveStrength ~., data = trainingSet, method = "earth",
                    tuneGrid = expand.grid(.degree = 1, .nprune = 2:25),
                    trControl = controlObject)
earthModel
```

```{r}
set.seed(669)
svmRModel <- train(CompressiveStrength ~., data = trainingSet, method = "svmRadial", tuneLength = 15, 
                   preProc = c("center","scale"), trControl = controlObject)
svmRModel
```

```{r}
library(caret)
nnetGrid <- expand.grid(.decay = c(0.001, 0.01, 0.1), .size = seq(1,27,by=2), .bag = FALSE)
set.seed(669)
nnetModel <- train(CompressiveStrength ~., data = trainingSet, method = "avNNet", 
                   tuneGrid = nnetGrid, preProc = c("center","scale"), linout = TRUE, trace = FALSE,
                   maxit = 1000, trControl = controlObject)
nnetModel
```


```{r}
set.seed(669)
rpartModel <- train(CompressiveStrength ~., data = trainingSet, method = "rpart", 
                    tuneLength = 30, trControl = controlObject)
rpartModel
```


```{r}
set.seed(669)
ctreeModel <- train(CompressiveStrength ~., data = trainingSet, method = "ctree",
                    tuneLength = 10, trControl = controlObject)
ctreeModel
```

```{r}
library(rJava)
library(RWeka)
set.seed(669)
mtModel <- train(CompressiveStrength ~., data =trainingSet, method = "M5", 
                 trControl = controlObject)
mtModel
```

```{r}
set.seed(669)
treebagModel <- train(CompressiveStrength ~., data = trainingSet, method = "treebag",
                      trControl = controlObject)
treebagModel
```

```{r}
set.seed(669)
rfModel <- train(CompressiveStrength ~., data = trainingSet, method = "rf", tuneLength = 10,
                 ntrees = 1000, importance = TRUE, trControl = controlObject)
rfModel
```

```{r}
gbmGrid <- expand.grid(.interaction.depth = seq(1,7,by=2), .n.trees = seq(100,1000,by=50), .shrinkage = c(0.01, 0.1), .n.minobsinnode=1)
set.seed(669)
gbmModel <- train(CompressiveStrength ~., data = trainingSet, method = "gbm", tuneGrid = gbmGrid,
                  verbose = FALSE, trControl = controlObject)
gbmModel
```


```{r}
cubistGrid <- expand.grid(.committees = c(1,5,10,50,75,100), .neighbors=c(0,1,3,5,7,9))
set.seed(669)
cbModel <- train(CompressiveStrength ~., data = trainingSet, method = "cubist",
                 tuneGrid = cubistGrid, trControl = controlObject)
cbModel
```



```{r}
allResamples <- resamples(list("Linear Reg" = linearReg, 
                               "PLS" = plsModel,
                               "Elastic Net" = enetModel,
                               MARS = earthModel,
                               SVM = svmRModel,
                               "Neural Networks" = nnetModel,
                               CART = rpartModel,
                               "Cond Inf Tree" = ctreeModel,
                               "Bagged Tree" = treebagModel,
                               "Boosted Tree" = gbmModel,
                               "Random Forest" = rfModel,
                               Cubist = cbModel))
```

```{r}
# Plot the RMSE values 
library(MASS)
library(caret)
parallelplot(allResamples)
```

```{r}
# Using R-Squared
parallelplot(allResamples, metric = "Rsquared")
```

```{r}
nnetPredictions <- predict(nnetModel, testData)
gbmPredictions <- predict(gbmModel, testData)
cbPredictions <- predict(cbModel, testData)
```


```{r}
age28Data <- subset(trainingData, Age == 28)

# Remove the age and compressive strength columns and then center and scale the predictor columns

pp1 <- preProcess(age28Data[,-(8:9)],c("center","scale"))
scaledTrain <- predict(pp1, age28Data[,1:7])
set.seed(91)
startMixture <- sample(1:nrow(age28Data),1)
starters <- scaledTrain[startMixture, 1:7]
```

```{r}
pool <- scaledTrain
index <- maxDissim(starters, pool, 14)
startPoints <- c(startMixture, index)
starters <- age28Data[startPoints,1:7]
```

```{r}
startingValues <- starters[,-4]
```

```{r}
# The inputs to the function are a vector of six mixture proportions (in argument 'x') and the model used for prediction ('mod')


modelPrediction <- function(x, mod) {
  if(x[1]<0|x[1]>1) return(10^38)
  if(x[2]<0|x[2]>1) return(10^38)
  if(x[3]<0|x[3]>1) return(10^38)
  if(x[4]<0|x[4]>1) return(10^38)
  if(x[5]<0|x[5]>1) return(10^38)
  if(x[6]<0|x[6]>1) return(10^38)
  
  # Determine the water proportion
  x <- c(x, 1-sum(x))
  # Check the water range
  if(x[7]<0.05) return(10^38)
  # Convert the vector to a data frame, assign names and fix age at 28 days
  tmp <- as.data.frame(t(x))
  names(tmp) <- c('Cement','BlastFurnaceSlag','FlyAsh','Superplasticizer','CoarseAggregate','FineAggregate','Water')
  tmp$Age <- 28
  # Get the model prediction, square them to get back to the original units, then return the negative of the result
  -predict(mod, tmp)
}
```

  
  
  
  
  
















