---
title: "Chapter 7"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.





# Chapter 7. Nonlinear Regression Models 

## 7.1 Neural Networks

## 7.2 Multivariate Adaptive Regression Splines 

## 7.3 Support Vector Machines 

## 7.4 K-Nearest Neighbours

## 7.5 Computing 

### Neural Networks

```{r}
library(nnet)
nnetFit <- nnet(predictors, outcome, size = 5, decay = 0.01, linout = TRUE,
                # reduce the amount of printed output
                trace = FALSE, 
                # Expand the number of iterations to find parameter estimates
                maxit = 500, 
                # and the number of parameters used by the model 
                MaxNWts = 5 * (ncol(predictors)+1)+5+1)
```

```{r}
nnetAvg <- avNNet(predictors, outcome, size = 5, decay = 0.01,
                  # specify how many models to average
                  repeats = 5, linout = TRUE, 
                  # reduce the amount of printed output 
                  trace = FALSE,
                  # expand the number of iterations to find parameter estimates
                  maxit = 500,
                  # and the number of parameters used by the model 
                  MaxNWts = 5 * (ncol(predictors) + 1) + 5 + 1)
```

```{r}
predict(nnetFit, newData)
predict(nnetAvg, newData)
```


```{r}
# The findCorrelation takes a correlation matrix and determines the column numbers that should be removed to keep all pair-wise correlations below a threshold 

library(caret)
tooHigh <- findCorrelation(cor(solTrainXtrans),cutoff = 0.75)
trainXnnet <- solTrainXtrans[,-tooHigh]
testXnnet <- solTestXtrans[,-tooHigh]

# create a specific candidate set of models to evaluate
nnetGrid <- expand.grid(.decay = c(0, 0.01, 0.1), .size = c(1:10),
                        # to use bagging instead of different random seeds
                        .bag = FALSE)

set.seed(100)
nnetTune <- train(solTrainXtrans, solTrainY, method = "avNNet", tuneGrid = nnetGrid, trControl = ctrl,
                  # automatically standardize data prior to modeling and prediction
                  preProc = c("center", "scale"), linout = TRUE, trace = FALSE, 
                  MaxNWts = 10 * (ncol(trainXnnet)+1)+10+1, maxit = 500)
```

```{r}
nnetTune
```


### Multivariate Adaptive Regression Splines 

```{r}
library(earth)
marsFit <- earth(solTrainXtrans, solTrainY)
marsFit
```

```{r}
summary(marsFit)
```

```{r, fig.height=5, fig.width=8}
plotmo(marsFit)
```

```{r}
# Define the candidate models to test 
marsGrid <- expand.grid(.degree = 1:2, .nprune = 2:38)

# Fix the seed so that the results can be reproduced 
set.seed(100)
marsTune <- train(solTrainXtrans, solTrainY, method = "earth",
                  # explicitly declare the candidate models to test 
                  tuneGrid = marsGrid, trControl = trainControl(method = "cv"))
marsTune
```

```{r}
head(predict(marsTune, solTestXtrans))
```

```{r}
varImp(marsTune)
```


### Support Vector Machines 


```{r}
library(kernlab)
svmFit <- ksvm(x = solTrainXtrans, y = solTrainY, kernel = "rbfdot", kpar = "automatic", C = 1, epsilon = 0.1)
```

```{r}
svmRTuned <- train(solTrainXtrans, solTrainY, method = "svmRadial", preProc = c("center","scale"), 
                  tuneLength = 14, trControl = trainControl(method = "cv"))
svmRTuned
```

```{r}
svmRTuned$finalModel
```


### K-Nearest Neighbors 

```{r}
# remove a few sparse and unbalanced fingerprints first 
knnDescr <- solTrainXtrans[,-nearZeroVar(solTrainXtrans)]
set.seed(100)
knnTune <- train(knnDescr, solTrainY, method = "knn", 
                 # center and scaling will occur for new predictions too
                 preProc = c("center", "scale"),
                 tuneGrid = data.frame(.k=1:20),
                 trControl = trainControl(method = "cv"))
knnTune
```

```{r}
plot(knnTune)
```

