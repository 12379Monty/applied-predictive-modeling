---
title: "Chapter 11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.




# Chapter 11. Measuring Performance in Classification Models


## 11.1 Class Predictions 

### Well-calibrated probabilities

### Presenting class probabilities

### Equivocal zones


## 11.2 Evaluating predicted classes

### Two-class problems 

### Non-accurarcy-based criteria


## 11.3 Evaluating class probabilities

### Receiver operating characteristic (ROC) curves

### Lift charts


## 11.4 Computing 

```{r}
library(AppliedPredictiveModeling)
library(caret)
library(klaR)
library(MASS)
library(pROC)
library(randomForest)
```

```{r}
set.seed(975)
simulatedTrain <- quadBoundaryFunc(500)
simulatedTest <- quadBoundaryFunc(1000)
head(simulatedTrain)
```

```{r}
rfModel <- randomForest(class ~ X1 + X2, data = simulatedTrain, ntree = 2000)
rfModel
```

```{r}
qdaModel <- qda(class ~ X1 + X2, data = simulatedTrain)
qdaModel
```

```{r}
qdaTrainPred <- predict(qdaModel, simulatedTrain)
names(qdaTrainPred)
```

```{r}
head(qdaTrainPred$class)
```

```{r}
head(qdaTrainPred$posterior)
```

```{r}
qdaTestPred <- predict(qdaModel, simulatedTest)
simulatedTrain$QDAprob <- qdaTrainPred$posterior[,"Class1"]
simulatedTest$QDAprob <- qdaTestPred$posterior[,"Class1"]
```

```{r}
rfTestPred <- predict(rfModel, simulatedTest, type = "prob")
head(rfTestPred)
```

```{r}
simulatedTest$RFprob <- rfTestPred[,"Class1"]
simulatedTest$RFclass <- predict(rfModel, simulatedTest)
```


### Sensitivity and specificity


```{r}
# Class 1 will be used as the event of interest

sensitivity(data = simulatedTest$RFclass, reference = simulatedTest$class, positive = "Class1")

specificity(data = simulatedTest$RFclass, reference = simulatedTest$class, negative = "Class2")
```

```{r}
posPredValue(data = simulatedTest$RFclass, reference = simulatedTest$class, positive = "Class1")

negPredValue(data = simulatedTest$RFclass, reference = simulatedTest$class, negative = "Class2")
```

```{r}
# Change the prevalence manually 
posPredValue(data = simulatedTest$RFclass, reference = simulatedTest$class, positive = "Class1", prevalence = 0.9)
```


### confusion matrix

```{r}
confusionMatrix(data = simulatedTest$RFclass, reference = simulatedTest$class, positive = "Class1")
```


### Receiver operating characteristic curves

```{r}
rocCurve <- roc(response = simulatedTest$class, predictor = simulatedTest$RFprob,
                # This function assumes that the second class is the event of interest, so we reverse the labels
                levels = rev(levels(simulatedTest$class)))
```

```{r}
auc(rocCurve)
ci.auc(rocCurve)
```

```{r}
plot(rocCurve, legacy.axes = TRUE)
# By default, the x-axis goes backwards, used the option legacy.axes = TRUE to get 1-spe on the x-axis moving from 0 to 1
# Also, another curve can be added using add=TRUE the next time plot.auc is used
```


### Lift charts

```{r}
labs <- c(RFprob="Random Forest", QDAprob = "Quadratic Discriminant Analysis")
liftCurve <- lift(class ~ RFprob + QDAprob, data = simulatedTest, labels = labs)
liftCurve
```

```{r}
# Add lattice options to produce a legend on top
xyplot(liftCurve)
```


### Calibrating probabilities

```{r}
calCurve <- calibration(class ~ RFprob + QDAprob, data = simulatedTest)
calCurve
```

```{r}
xyplot(calCurve, auto.key=list(columns = 2))
```

```{r}
# The glm() function models the probabilities of the second factor level, so the function revevel() is used to temporarily reverse the factors levels

sigmoidalCal <- glm(relevel(class, ref = "Class2") ~ QDAprob, data = simulatedTrain, family = binomial)
coef(summary(sigmoidalCal))
```

```{r}
sigmoidProbs <- predict(sigmoidalCal, newdata = simulatedTest[,"QDAprob", drop = FALSE], type = "response")
simulatedTest$QDAsigmoid <- sigmoidProbs
```

```{r}
BayesCal <- NaiveBayes(class ~ QDAprob, data = simulatedTrain, usekernel = TRUE)
# Like qda(), the predict function for this model creates both the classes and the probabilities

BayesProbs <- predict(BayesCal, newdata = simulatedTest[,"QDAprob", drop = FALSE])

simulatedTest$QDABayes <- BayesProbs$posterior[,"Class1"]

# The probability values before and after calibration

head(simulatedTest[,c(5:6,8,9)])
```

```{r}
calCurve2 <- calibration(class ~ QDAprob + QDABayes + QDAsigmoid, data = simulatedTest)
xyplot(calCurve2)
```










